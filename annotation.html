 @Configuration
The annotation indicates to Spring that this is a configuration class that will @Configuration
provide beans to the Spring application context. The configuration’s class methods are annotated
with , indicating that the objects they return should be added as beans in the application @Bean
context (where, by default, their respective bean IDs will be the same as the names of the
methods that define them).
Java-based configuration offers several benefits over XML-based configuration, including
greater type safety and improved refactorability. Even so, explicit configuration with either Java
or XML is only necessary if Spring is unable to automatically configure the components.
Automatic configuration has its roots in the Spring techniques known as and autowiring
component scanning. With component scanning, Spring can automatically discover components
from an application’s classpath and create them as beans in the Spring application context. With
autowiring, Spring automatically injects the components with the other beans that they depend
on.
More recently, with the introduction of Spring Boot, automatic configuration has gone well
beyond component scanning and autowiring. Spring Boot is an extension of the Spring
Framework that offers several productivity enhancements. The most well-known of these
enhancements is , where Spring Boot can make reasonable guesses of what autoconfiguration
components need to be configured and wired together, based on entries in the classpath,
environment variables, and other factors.

@SpringBootApplication is a composite annotation that combines three other annotations:

@SpringBootConfiguration — Designates this class as a configuration class. Although
there’s not much configuration in the class yet, you can add Java-based Spring

@EnableAutoConfiguration — Enables Spring Boot automatic configuration. We’ll
talk more about autoconfiguration later. For now, know that this annotation tells Spring
Boot to automatically configure any components that it thinks you’ll need.

@ComponentScan — Enables component scanning. This lets you declare other classes
with annotations like @Component @Controller @Service
automatically discover them and register them as components in the Spring application
context

The @SpringBootTest annotation tells JUnit to bootstrap the test with Spring Boot capabilities.
Just like @SpringBootApplication, @SpringBootTest is a composite annotation, which is
itself annotated with @ExtendWith(SpringExtension.class), to add Spring testing
capabilities to JUnit 5. For now, though, it’s enough to think of this as the test class equivalent of
calling SpringApplication.run() in a main() method. Over the course of this book, you’ll
see @SpringBootTest several times, and we’ll uncover some of its power.

@WebMvcTest. This is a
special test annotation provided by Spring Boot that arranges for the test to run in the context of
a Spring MVC application. More specifically, in this case, it arranges for Controller to be
registered in Spring MVC so that you can throw requests against it.
@WebMvcTest also sets up Spring support for testing Spring MVC. Although it could be made to
start a server, mocking the mechanics of Spring MVC is sufficient for your purposes. The test
class is injected with a MockMvc object for the test to drive the mockup.

